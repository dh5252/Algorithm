<프로그래밍 대회를 위한 코드작성법>

1. 간결한 코드 작성 : 오타나 단순한 버그가 생길 우려 줄어듬.
2. 적극적인 코드 재사용 : 코드를 모듈화하자. 함수나 클래스로 분리하여 처리. (3번이상 같은 함수가 반복된다면 함수로 분리)
3. 표준 라이브러리 공부 : C++의 경우 STL 공부하기! (문자열, 동적 배열, 스택, 큐, 리스트, 딕셔너리)
4. 항상 같은 형태로 프로그램 작성 : 검증된 코드를 짜고, 자주 사용하여 익숙하게 만들자!
5. 일관적이고 명료한 명명법 사용 : 함수가 어떤일을 하는지 쉽게 알 수 있게 명명.
6. 모든 자료 정규화 : 자료의 표현방식을 정규화하여 쉽게 데이터 처리하기.
7. 코드와 데이터 분리 : ex) int daysIn[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

<자주 하는 실수>

1. 산술 오버플로우 : 어떤 식의 계산 값이 반환되는 자료형의 표현가능한 범위를 벗어나는 경우.
	(1) 너무 큰 결과 : 32비트 정수, 64비트 정수 잘 선택하기
	(2) 너무 큰 중간 값 : 계산의 중간값이 32비트 정수를 넘을 수 있다는 점 유의.
	(3) 너무 큰 무한대 값 : 최소값 계산할 때 무한대 값을 임의로 설정해서 최소를 가려내는 테크닉이 있는데, 오버플로우에 유의하자. 987,654,321이용 2^30에 가까운 매우 큰 값이어서 오타가 났는지 아닌지 유용하게 확인가능하다.
	(4) 오버플로우 피해가기 : 자료형 64비트 쓰기, 연산의 순서 바꾸기
	(5) 실수 연산 오류 : 컴퓨터에서 실수 연산을 하면 오차가 생길 수밖에없다.
		-> bool doubleEqual(double a, double b){ 	//double 형 비교 연산. (대소 비교에도 이 함수로 먼저 체크하기.)
			double diff = fabs(a-b);  
			if (diff < 1e-10) return true;	// 절대 오차가 허용범위 안일 경우 true 반환.
			return diff <= ie-8 * max(fabs(a), fabs(b)); // 그 외의 경우에는 상대오차 사용.
		}
		-> 귀찮다면 분모/분자를 멤버로 가진 클래스 만들기.
		-> 실수 연산을 하지 않도록 문제 변형하기 : ex. 곱셈 나눗셈 순서 바꾸기. 양변 제곱하기. 실수좌표에서 좌표계를 정수배 늘리기.
2. 배열 범위 밖 원소에 접근 : 배열 크기를 정할때 신중하게 정하기!
3. 일관되지 않은 범위 표현방식 사용 : [a,b) 사용하기! (반열린구간) begin() : 첫번째원소 가리킴 , end() : 마지막원소의 다음 가리킴. 
4. Off-by-one 오류 : 계산의 큰 줄기는 맞지만, 예외처리가 안된경우. 극단적인 값을 생각하여 해결!
5. 상수 오타 : 문제에서 주어진대로 오타 없이 출력하기! 64비트 정수형, 32비트 정수형 구분.
6. 스택 오버플로우 : 재귀호출의 깊이 너무 깊게 하지 않기. 힙에 메모리를 할당하는 STL 컨테이너 혹은 전역변수를 사용하자.
7. 너무 느린 입출력 방식 선택 : 고수준 입출력 방식 이용(ex.cin)할 때, 속도 저하. (입출력의 양이 1만개 이상일 때 고려하기)
8. 변수 초기화 문제 : 변수 한 번 쓰고 초기화하기.

<디버깅과 테스팅>
-> 프로그래밍 대회 특성상 코드가 짧아 디버거를 키는 대신, 눈 디버깅이 더 유용함.

1. 작은 입력에 대해 제대로 실행되나 확인 : 예제입력의 크기가 클 경우 입력을 작게하여 오류 찾기
2. 단정문(assertion) 사용 : 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료시키는 함수. 
3. 계산 중간 결과 출력 : 중간에 어디가 잘못됐는지 쉽게 파악가능!
4. 런타임 오류가 났을때 : 디버거를 사용해도 괜찮다!

-> 제출 전에 예제 입력을 만들어 가능한 한 프로그램을 많이 테스트해보자.
*스캐폴딩 기법* 입력을 자동으로 생성하는 함수를 만들어 테스트해보기.

