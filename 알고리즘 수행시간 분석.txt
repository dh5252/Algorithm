<알고리즘의 평가 기준>
1. 시간 : 알고리즘의 수행 속도, 특성
2. 공간 : 알고리즘 수행시 사용하는 메모리

<알고리즘의 시간 복잡도 분석>
-> 알고리즘의 수행 시간을 지배하는 것은 '반복문'

1. 선형시간 알고리즘 : 입력값과 시간 그래프가 1차함수! 입력값과 시간이 정비례하는 경우이다. 대개 우리가 찾을 수 있는 알고리즘 중 가장 좋은 알고리즘이다! **소요 시간 : N**

2. 선형 이하 시간 알고리즘 : 예를 들면 이진탐색이 있다. 입력값의 증가보다 소요시간의 증가가 작은 알고리즘이다! **소요 시간 : logN **

3. 다항 시간 알고리즘 : 변수 N과 N^2, 그 외 거듭제곱들의 선형결합의 시간이 걸리는 알고리즘. **소요 시간 : N^c (c는 자연수) **

4. 지수 시간 알고리즘 : ex. 2^N의 시간. 프로그램에 지대한 영향을 미침.  **소요 시간 : c^N (c는 2이상의 자연수)**

<빅O를 통한 시간 복잡도>
1. 최악의 수행시간 고려
2. 반복문의 반복 수만 고려, 빅O표기법 사용. ex. (N^2)M + NlogM + NM^2 = O((N^2)M + NM^2)  (N^2)M과 NM^2 중 어떤 것이 큰 지 모르므로 두가지 모두 표기.

<수행시간 어림 짐작 하기>
--> 주먹구구 법칙 : 입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행횟수에 대해, 1초당 반복문 수행 횟수가 1억(10^8)을 넘어가면 시간 제한을 초과할 가능성이 있다.
				이 법칙을 적용할 때는 충분한 여유를 두는것이 좋음. 맹신하지 말자.
				**고려해야하는 요소**
				(1) 시간 복잡도가 프로그램의 실제 수행 속도를 반영하지 못하는 경우.
				(2) 반복문의 내부가 복잡한 경우.
				(3) 메모리 사용 패턴이 복잡한 경우.
				(4) 언어와 컴파일러의 차이. (최적화 옵션을 켠 C++ 사용하자)
				(5) 구형 컴퓨터를 사용하는 경우.